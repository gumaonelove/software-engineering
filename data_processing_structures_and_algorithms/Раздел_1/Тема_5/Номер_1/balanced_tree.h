//
// Created by Булат Гумеров on 18.03.2023.
//

#ifndef DATA_PROCESSING_STRUCTURES_AND_ALGORITHMS_MAIN_H
#define DATA_PROCESSING_STRUCTURES_AND_ALGORITHMS_MAIN_H


#include<iostream>

using namespace std;

/*
ИДЕАЛЬНО СБАЛАНСИРОВАННОЕ ДВОИЧНОЕ ДЕРЕВО

Двоичное(каждая вершина имеет не более 2 потомков) дерево называется идеально сбалансированным (ИСД)
если для каждой его вершины размеры левого и правого поддеревьев отличаются не более чем на 1.

1. Обход в прямом направлении:
-обработать корневую вершину текущего поддерева
-перейти к обработке левого поддерева таким же образом
-обработать правое поддерево таким же образом
                   /     (А)
                  /     /   \
                 /     /     \
                /    (В)      (С)
               |
                ----------------->

2. Симметричный обход:
-рекурсивно обработать левое поддерево текущего поддерева
-обработать вершину текущего поддерева
-рекурсивно обработать правое поддерево
                     -----------
                   /     (А)    \
                  /     /   \    \
                 /     /     \    \
                /    (В)      (С)  \
               /                    \->

3. Обход в обратно-cимметричном направлении:
-рекурсивно обработать правое поддерево текущего поддерева
-вершину текущего поддерева
-затем рекурсивно обработать правое поддерево
                     -----------
                   /     (А)    \
                  /     /   \    \
                 /     /     \    \
                /    (В)      (С)  \
            <- /

*/

int N; //количество вершин в дереве, глобальная переменная


//ОПИСАНИЕ СТРУКТУРЫ ДЕРЕВА TreePoint
struct Tp {
    int value; //строка-значение
    Tp* Left; //ссылочная переменная-указатель на левый элемент
    Tp* Right; //ссылочная переменная-указатель на правый элемент
} *pRoot; //ссылочная переменная для адреса корневой вершины.


//ДОБАВЛЕНИЕ ВЕРШИН (ПОСТРОЕНИЕ ИСД)
Tp* AddNodes(Tp* pCurrent, int aN)
{
    Tp* pTemp;
    int Nl, Nr;
    if (aN == 0)  // если нет вершин для размещения
        return NULL; // формируем пустую ссылку
    else {
        Nl = aN / 2; //число вершин слева
        Nr = aN - Nl - 1; //число вершин справа
        pTemp = new Tp; //создаем корень поддерева, выделяем память
        pTemp->value = rand() % 100; //заносим в информационную часть случайное целое число в интервале от 0 до 99
        pTemp->Left = AddNodes(pTemp->Left, Nl); // уходим на создание левого поддерева
        pTemp->Right = AddNodes(pTemp->Right, Nr); // уходим на создание правого поддерева
        pCurrent = pTemp;
        //        cout << "\n Вершина создана\n";
        return pTemp; //возвращаем адрес созданного корня
    }
}


//ОЧИСТКА ПАМЯТИ
void delTp(Tp* pCurrent) {
    if (pCurrent != NULL) {
        delTp(pCurrent->Left); // сначала удалять все элементы с левого конца
        delTp(pCurrent->Right); // потом удалять все элементы с правого конца
        delete pCurrent; // в конце удалить сам элемент-корень
    }
};


#endif //DATA_PROCESSING_STRUCTURES_AND_ALGORITHMS_MAIN_H
