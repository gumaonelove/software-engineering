'''Задача A: Сортировка слиянием с приколом
Это задача требует от вас написать сортировку слиянием для за заданного массива
Разумеется, все не так просто. Мы хотим, чтобы вы не смогли сдать какой-нибудь
А значит, мы попросим от вас посчитать количество инверсий в массиве. Для этого вам потребуется модифицировать стадию
слияния массивов — попробуйте понять, что происходит с числом инверсий при слиянии двух массивов. Мы подскажем,
что в отсортированном массиве 0 инверсий, а операция merge принимает два отсортированных массива и сливает их в
один большой отсортированный массив.
Количество инверсий — это количество пар таких, что.
Обратите внимание на то, что ответ может не влезать в 32-битный тип данных, если вы пишете не на python.'''

n = int(input())
A = [int(i) for i in input().split()[:n]]

count: int = 0


def merge(_A: list, _B: list) -> list:
    '''Слияние массивов'''
    global count
    a, b = 0, 0
    res = []
    _A.append(float("inf"))
    _B.append(float("inf"))

    while (a + b < len(_A) + len(_B)) and not (_B[b] == _A[a] == float("inf")):
        if _A[a] <= _B[b]:
            res.append(_A[a])
            a += 1
        else:
            res.append(_B[b])
            b += 1
            if _A[a] != float("inf"):
                count += len(_A) - a - 1
    return res


def merge_sorted(_A: list) -> list:
    '''Сортировка слиянием'''
    _n = len(_A)

    if _n == 1:
        return _A
    elif _n == 2:
        return merge(_A[0: _n // 2], _A[_n // 2:])
    else:
        return merge(
            merge_sorted(_A[0: _n // 2]),
            merge_sorted(_A[_n // 2:])
        )


result = merge_sorted(A)
print(count)
print(*result)